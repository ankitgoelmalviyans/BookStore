trigger: none

variables:
- group: BookStoreSecrets
- name: azureSubscription
  value: 'AzureServiceConnectionName'
- name: aksClusterName
  value: 'bookstore-aks'
- name: aksResourceGroup
  value: 'BookStoreRG'
- name: namespace
  value: 'bookstore'
- name: imageRepository
  value: 'productservice'
- name: imageRepositoryInventory
  value: 'inventoryservice'
- name: containerRegistry
  value: 'bookstoreaure.azurecr.io'
- name: imageTag
  value: 98
- name: apimResourceGroup
  value: 'BookStoreRG'
- name: apimInstance
  value: 'bookstore-apim-new-1'

stages:
- stage: Deploy
  displayName: 'Deploy Services to AKS'
  jobs:
  - job: DeployToKubernetes
    displayName: 'Deploy ProductService and InventoryService'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      displayName: 'Create Shared Secret and Deploy Services'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
          kubectl get namespace $(namespace) || kubectl create namespace $(namespace)

          echo "Creating shared Kubernetes secret..."
          kubectl create secret generic bookstore-common-secrets \
            --from-literal=Jwt__Key=$(JwtKey) \
            --from-literal=Kafka__BootstrapServers=$(KafkaBootstrapServers) \
            --from-literal=Kafka__Username=$(KafkaUsername) \
            --from-literal=Kafka__Password=$(KafkaPassword) \
            --from-literal=Cosmos__Endpoint=$(CosmosEndpoint) \
            --from-literal=Cosmos__Key=$(CosmosKey) \
            --from-literal=ServiceBus__Connection=$(ServiceBusConnection) \
            --namespace=$(namespace) --dry-run=client -o yaml | kubectl apply -f -

          echo "Deploying ProductService..."
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: productservice
            namespace: $(namespace)
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: productservice
            template:
              metadata:
                labels:
                  app: productservice
              spec:
                containers:
                - name: productservice
                  image: $(containerRegistry)/$(imageRepository):$(imageTag)
                  ports:
                  - containerPort: 80
                  env:
                  - name: ASPNETCORE_URLS
                    value: http://+:80
                  envFrom:
                  - secretRef:
                      name: bookstore-common-secrets
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: productservice
            namespace: $(namespace)
          spec:
            selector:
              app: productservice
            ports:
              - protocol: TCP
                port: 80
                targetPort: 80
            type: LoadBalancer
          EOF

          echo "Deploying InventoryService..."
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: inventoryservice
            namespace: $(namespace)
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: inventoryservice
            template:
              metadata:
                labels:
                  app: inventoryservice
              spec:
                containers:
                - name: inventoryservice
                  image: $(containerRegistry)/$(imageRepositoryInventory):$(imageTag)
                  ports:
                  - containerPort: 80
                  env:
                  - name: ASPNETCORE_URLS
                    value: http://+:80
                  envFrom:
                  - secretRef:
                      name: bookstore-common-secrets
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: inventoryservice
            namespace: $(namespace)
          spec:
            selector:
              app: inventoryservice
            ports:
              - protocol: TCP
                port: 80
                targetPort: 80
            type: LoadBalancer
          EOF

- stage: ImportToAPIM
  displayName: 'Import APIs to APIM'
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: ImportAPI
    displayName: 'Import Swagger to APIM and Update serviceUrl'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      displayName: 'Import and Update APIs'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing

          echo "Fetching ProductService External IP..."
          RETRIES=10
          EXTERNAL_IP=""
          while [ -z "$EXTERNAL_IP" ] && [ $RETRIES -gt 0 ]; do
            EXTERNAL_IP=$(kubectl get svc productservice -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -z "$EXTERNAL_IP" ]; then
              sleep 15
              RETRIES=$((RETRIES - 1))
            fi
          done

          if [ -z "$EXTERNAL_IP" ]; then
            echo "Could not fetch ProductService IP."
            exit 1
          fi

          echo "Importing ProductService API..."
          az apim api import \
            --resource-group $(apimResourceGroup) \
            --service-name $(apimInstance) \
            --api-id productservice-api \
            --path product \
            --display-name "ProductService API" \
            --specification-url "http://$EXTERNAL_IP/swagger/v1/swagger.json" \
            --specification-format OpenApi

          echo "Updating ProductService API serviceUrl..."
          az apim api update \
            --resource-group $(apimResourceGroup) \
            --service-name $(apimInstance) \
            --api-id productservice-api \
            --set serviceUrl=http://$EXTERNAL_IP

          echo "Fetching InventoryService External IP..."
          RETRIES=10
          INVENTORY_IP=""
          while [ -z "$INVENTORY_IP" ] && [ $RETRIES -gt 0 ]; do
            INVENTORY_IP=$(kubectl get svc inventoryservice -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -z "$INVENTORY_IP" ]; then
              sleep 15
              RETRIES=$((RETRIES - 1))
            fi
          done

          if [ -z "$INVENTORY_IP" ]; then
            echo "Could not fetch InventoryService IP."
            exit 1
          fi

          echo "Importing InventoryService API..."
          az apim api import \
            --resource-group $(apimResourceGroup) \
            --service-name $(apimInstance) \
            --api-id inventoryservice-api \
            --path inventory \
            --display-name "InventoryService API" \
            --specification-url "http://$INVENTORY_IP/swagger/v1/swagger.json" \
            --specification-format OpenApi

          echo "Updating InventoryService API serviceUrl..."
          az apim api update \
            --resource-group $(apimResourceGroup) \
            --service-name $(apimInstance) \
            --api-id inventoryservice-api \
            --set serviceUrl=http://$INVENTORY_IP

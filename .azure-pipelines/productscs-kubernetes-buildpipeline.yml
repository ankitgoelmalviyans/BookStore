trigger: none
# ğŸ›‘ This pipeline does NOT trigger automatically on code push.
# Manual or YAML-referenced run is required.

variables:
  dockerRegistryServiceConnection: 'MyACRConnection'  # ğŸ” Azure DevOps service connection to authenticate with Azure Container Registry (ACR)
  imageRepository: 'productservice'  # ğŸ“¦ Repository name for ProductService Docker image inside ACR
  imageRepositoryInventory: 'inventoryservice'  # ğŸ“¦ Repository name for InventoryService image
  containerRegistry: 'bookstoreaure.azurecr.io'  # ğŸŒ FQDN of ACR instance
  dockerfilePath: 'BookStore.ProductSCA/BookStore.ProductService/src/BookStore.ProductService.API/Dockerfile'  # ğŸ“„ Location of Dockerfile for ProductService
  dockerfilePathInventory: 'BookStore.ProductSCA/BookStore.InventoryService/InventoryService.API/Dockerfile'  # ğŸ“„ Location of Dockerfile for InventoryService
  buildContext: 'BookStore.ProductSCA/BookStore.ProductService/src'  # ğŸ“ Build context directory for ProductService (root where Dockerfile can access all needed code)
  buildContextInventory: 'BookStore.ProductSCA/BookStore.InventoryService'  # ğŸ“ Build context for InventoryService
  tag: '$(Build.BuildId)'  # ğŸ”– Automatically uses Azure DevOps build ID as Docker tag (ensures unique tag for each build)

pool:
  vmImage: 'ubuntu-latest'  # ğŸ§± Uses latest Ubuntu VM image to run this job (Docker compatible)

stages:
- stage: BuildAndPush
  displayName: 'Build and Push Docker Image to ACR'
  # ğŸš€ This stage builds and pushes Docker images for both services, then prepares Azure Function Proxy ZIP

  jobs:
  - job: Build
    displayName: 'Docker Build and Push'
    # ğŸ”§ This job handles building both Docker images and preparing function zip artifact

    steps:
    - task: Docker@2
      displayName: 'Build and Push Image Product'
      # ğŸ—ï¸ Builds ProductService Docker image using Dockerfile and pushes it to ACR
      inputs:
        command: buildAndPush  # ğŸ” Performs both build and push in a single task
        containerRegistry: $(dockerRegistryServiceConnection)  # ğŸ” Uses service connection for ACR auth
        repository: $(imageRepository)  # ğŸ“¦ Target repo in ACR: productservice
        dockerfile: $(dockerfilePath)  # ğŸ“„ Path to ProductService Dockerfile
        buildContext: $(buildContext)  # ğŸ“ Folder where build context starts
        tags: |
          $(tag)  # ğŸ·ï¸ Uses current build ID as the tag

    - task: Docker@2
      displayName: 'Build and Push Image Inventory'
      # ğŸ—ï¸ Builds InventoryService Docker image and pushes to ACR
      inputs:
        command: buildAndPush
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(imageRepositoryInventory)  # ğŸ“¦ ACR repo: inventoryservice
        dockerfile: $(dockerfilePathInventory)
        buildContext: $(buildContextInventory)
        tags: |
          $(tag)

    - task: ArchiveFiles@2
      displayName: 'Zip Azure Function Proxy'
      # ğŸ“¦ Archives (ZIPs) the Azure Function proxy folder so it can be deployed later via release pipeline
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/BookStore.FunctionProxy'  # ğŸ“ Source folder to zip
        includeRootFolder: false  # ğŸ“¦ Only include contents of folder, not folder itself
        archiveType: 'zip'
        archiveFile: '$(Pipeline.Workspace)/drop/azure-function-proxy.zip'  # ğŸ“Œ Output zip path
        replaceExistingArchive: true  # â™»ï¸ Overwrite if zip already exists

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Function Proxy ZIP'
      # â˜ï¸ Publishes the zip file to DevOps so it can be picked up by release pipeline
      inputs:
        PathtoPublish: '$(Pipeline.Workspace)/drop/azure-function-proxy.zip'  # ğŸ“ Path of ZIP file
        ArtifactName: 'functionproxyzip'  # ğŸ·ï¸ Name of published artifact
        publishLocation: 'Container'  # ğŸ“¦ Stores in DevOps artifact container
